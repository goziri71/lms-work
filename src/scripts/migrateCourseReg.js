import fs from "fs";
import path from "path";
import url from "url";
import dotenv from "dotenv";
import { db } from "../database/database.js";

dotenv.config({ debug: false });

function getAbsolutePath(inputPath) {
  if (!inputPath) return null;
  // Support Windows absolute paths like C:\...
  if (/^[a-zA-Z]:\\/.test(inputPath) || inputPath.startsWith("\\\\")) {
    return inputPath;
  }
  const __filename = url.fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);
  return path.resolve(__dirname, inputPath);
}

function extractInsertTuples(sqlText) {
  // Find the INSERT INTO `course_reg` ... VALUES (...),(...),...;
  const insertRegex =
    /INSERT\s+INTO\s+`?course_reg`?\s*\([^\)]*\)\s*VALUES\s*([\s\S]*?);/i;
  const match = sqlText.match(insertRegex);
  if (!match) return [];
  const valuesBlob = match[1].trim();
  // Split top-level tuples by '),\n(' while respecting content
  // A simple approach: break by regex on \),\s*\( boundaries.
  const parts = valuesBlob
    .replace(/^\(/, "")
    .replace(/\)$/, "")
    .split(/\)\s*,\s*\(/);
  return parts.map((tupleStr) => `(${tupleStr})`);
}

function parseTuple(tupleStr) {
  // Expect format: (171, 1, 369, '2023/2024', '1ST', '2023-07-05', 40, NULL, 0, 0, '', 0, 0, 0, 0)
  // We'll parse by walking characters to handle quoted strings and NULLs.
  const values = [];
  let i = 0;
  const s = tupleStr.trim();
  if (s[0] === "(") i++;
  let current = "";
  let inString = false;
  while (i < s.length) {
    const ch = s[i];
    if (inString) {
      if (ch === "'") {
        if (s[i + 1] === "'") {
          // Escaped quote inside string
          current += "'";
          i += 2;
          continue;
        }
        inString = false;
        i++;
        continue;
      }
      current += ch;
      i++;
      continue;
    }
    if (ch === "'") {
      inString = true;
      i++;
      continue;
    }
    if (ch === "," || ch === ")") {
      const raw = current.trim();
      if (raw.toUpperCase() === "NULL" || raw === "") {
        values.push(null);
      } else if (/^[-+]?\d+$/.test(raw)) {
        values.push(parseInt(raw, 10));
      } else if (/^[-+]?\d*\.\d+$/.test(raw)) {
        values.push(parseFloat(raw));
      } else {
        values.push(raw);
      }
      current = "";
      if (ch === ")") break;
      i++;
      continue;
    }
    current += ch;
    i++;
  }
  return values;
}

async function ensureTable() {
  const createSQL = `
    CREATE TABLE IF NOT EXISTS course_reg (
      id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      student_id integer,
      course_id integer,
      academic_year varchar(20),
      semester varchar(20),
      date varchar(20),
      course_reg_id integer,
      ref varchar(50),
      program_id integer,
      facaulty_id integer,
      level varchar(5),
      first_ca integer NOT NULL,
      second_ca integer NOT NULL,
      third_ca integer NOT NULL,
      exam_score integer NOT NULL
    );
  `;
  await db.query(createSQL);
}

async function bulkInsert(valuesArray, chunkSize = 1000) {
  if (!valuesArray.length) return;
  const cols = [
    "id",
    "student_id",
    "course_id",
    "academic_year",
    "semester",
    "date",
    "course_reg_id",
    "ref",
    "program_id",
    "facaulty_id",
    "level",
    "first_ca",
    "second_ca",
    "third_ca",
    "exam_score",
  ];

  for (let start = 0; start < valuesArray.length; start += chunkSize) {
    const slice = valuesArray.slice(start, start + chunkSize);
    const flat = [];
    const placeholders = slice
      .map((row, rIdx) => {
        const base = rIdx * cols.length;
        flat.push(...row);
        const ph = cols.map((_, cIdx) => `$${base + cIdx + 1}`);
        return `(${ph.join(", ")})`;
      })
      .join(", ");

    const sql = `INSERT INTO course_reg (${cols.join(
      ", "
    )}) VALUES ${placeholders}`;
    await db.query(sql, { bind: flat });
  }
}

async function fixIdentitySequence() {
  const sql = `SELECT setval(pg_get_serial_sequence('course_reg','id'), (SELECT COALESCE(MAX(id), 0) FROM course_reg));`;
  await db.query(sql);
}

async function main() {
  const inputPath =
    process.argv[2] || "c:/Users/USER/OneDrive/Documents/course_reg.sql";
  const absPath = getAbsolutePath(inputPath);
  if (!absPath || !fs.existsSync(absPath)) {
    console.error("SQL file not found:", inputPath);
    process.exit(1);
  }
  const sqlText = fs.readFileSync(absPath, "utf8");

  const tuples = extractInsertTuples(sqlText);
  if (!tuples.length) {
    console.error("No INSERT tuples found in dump.");
    process.exit(1);
  }

  const rows = tuples.map(parseTuple);

  await db.transaction(async () => {
    await ensureTable();
    await bulkInsert(rows, 1000);
    await fixIdentitySequence();
  });

  // Verify count
  const [result] = await db.query(
    "SELECT COUNT(*)::int AS count FROM course_reg"
  );
  const count = Array.isArray(result) ? result[0].count : result.count;
  console.log(`Imported rows: ${count}`);
  process.exit(0);
}

main().catch((err) => {
  console.error("Migration failed:", err?.message || err);
  if (process.env.NODE_ENV === "development") {
    console.error(err);
  }
  process.exit(1);
});
